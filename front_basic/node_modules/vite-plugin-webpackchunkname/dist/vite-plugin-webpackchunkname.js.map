{"version":3,"file":"vite-plugin-webpackchunkname.js","sources":["../src/share.ts","../src/manualChunksConfig.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["import { basename, extname } from 'path'\nimport { moduleImpoterMap } from './type.d'\nimport { normalizePath } from '@rollup/pluginutils'\n\nconst APP_ROOT_PATH = normalizePath(process.cwd())\nexport const appRootPathRE = new RegExp(APP_ROOT_PATH, 'i')\nexport const userJSFilePathRE = new RegExp(\n  APP_ROOT_PATH + '/(?!node_modules).*\\\\.[tj]s[x]?$',\n  'i'\n)\nexport const CHUNK_NAME_TAG = 'chunkName'\nexport const chunkNameRE = /\\?chunkName=([\\w-.]*)/\nexport const bundleName = {\n  main: 'common',\n  vendor: 'vendor',\n}\nexport const fileNameDelimiter = '__'\n\nexport const getFileName = (filePath: string) => {\n  return basename(filePath, extname(filePath))\n}\n\nlet __moduleDeps: moduleImpoterMap = null\nexport const moduleDeps = {\n  get(id: string) {\n    return __moduleDeps[id]\n  },\n  set(v: moduleImpoterMap) {\n    __moduleDeps = v\n  },\n}\n\nlet __appDepMap: moduleImpoterMap = null\nexport const appModuleIdChunkNamesMap = {\n  get(id: string) {\n    return __appDepMap[id]\n  },\n  set(v: moduleImpoterMap) {\n    __appDepMap = v\n  },\n}\n","import type { GetModuleInfo } from 'rollup'\nimport {\n  bundleName,\n  chunkNameRE,\n  appRootPathRE,\n  moduleDeps,\n  appModuleIdChunkNamesMap,\n  fileNameDelimiter,\n} from './share'\n\nconst fileNameDelimiterRegExp = new RegExp(fileNameDelimiter, 'g')\n\nconst cssLangs = `\\\\.(css|less|sass|scss|styl|stylus|pcss|postcss)($|\\\\?)`\nconst cssLangRE = new RegExp(cssLangs)\nconst isCSSRequest = (request: string): boolean => cssLangRE.test(request)\n\nconst __moduleInVenderMap = new Map<string, boolean>()\n\n// rollup 把入口文件打包成index-[hash].js，名字 index.html 保持一致\n// 此文件【不export】任何变量，所以即使部分内容发生变化，也能保证多数包能够被长效缓存\n/**\n * 打包策略（靠前优先）：\n * 1. 从入口文件引入的三方包，打包成 vendor\n * 2. 路由带有 webpackChunkName 的，按给定的名称打包\n * 3. 文件有且只有一次引用，按 rollup 默认逻辑\n * 4. 文件多次引用\n *  4.1 如果是 node_modules 模块，按包名打包\n *  4.2 如果是用户模块按照 getAppModuleChunkName 中的逻辑打包\n */\n\nexport function manualChunksConfig(\n  id: string,\n  opts: { getModuleInfo: GetModuleInfo }\n) {\n  const { getModuleInfo } = opts\n  const cacheIdMap = new Map<string, boolean>()\n  const nodeModuleInfo = moduleDeps.get(id)\n  const isNodeModules = !!nodeModuleInfo\n\n  // vite 用的模块，譬如：__vite-browser-external，plugin-vue:export-helper 等\n  const isInternalModule = !appRootPathRE.test(id)\n  const isThirdPackageImportByEntry =\n    isNodeModules &&\n    !isCSSRequest(id) &&\n    staticImportedByEntry(id, getModuleInfo, cacheIdMap)\n  if (isThirdPackageImportByEntry || isInternalModule) {\n    if (nodeModuleInfo && !__moduleInVenderMap.has(nodeModuleInfo.name)) {\n      __moduleInVenderMap.set(nodeModuleInfo.name, true)\n    }\n    return bundleName.vendor\n  }\n\n  const matchedChunkName = chunkNameRE.exec(id)\n  if (matchedChunkName) {\n    return formatChunkName(matchedChunkName[1])\n  }\n\n  const { importers } = getModuleInfo(id)\n  if (importers.length < 2) {\n    return void 0\n  }\n\n  //importers 大于 1 就存在chunk之间的引用\n\n  // 处理node_modules中的依赖\n  if (nodeModuleInfo) {\n    const rootModule = [...nodeModuleInfo.chunkNames]\n    let chunkName = rootModule[0]\n    if (rootModule.length >= 2) {\n      chunkName = nodeModuleInfo.name\n    }\n    if (__moduleInVenderMap.has(chunkName)) {\n      chunkName = bundleName.vendor\n    }\n    return chunkName || bundleName.main\n  }\n\n  const appModuleInfo = appModuleIdChunkNamesMap.get(id)\n  if (appModuleInfo) {\n    const chunkNames = [...appModuleInfo.chunkNames].filter(Boolean)\n    const name = getAppModuleChunkName(chunkNames)\n    return formatChunkName(name)\n  }\n}\n\nfunction getAppModuleChunkName(chunkNames: string[]) {\n  if (chunkNames.indexOf(bundleName.main) >= 0) {\n    return bundleName.main\n  }\n\n  const names = chunkNames.filter((i: string) => i !== bundleName.main)\n  switch (names.length) {\n    case 1:\n      return names[0]\n    case 2:\n      return assembleChunkName(names)\n    default:\n      return bundleName.main\n  }\n}\n\nfunction assembleChunkName(names: string[]) {\n  const [c1, c2] = names.sort((a, b) => (a > b ? 1 : a < b ? -1 : 0))\n  return `shared/${c1}/${c2}`\n}\n\nfunction formatChunkName(name: string) {\n  return name.replace(fileNameDelimiterRegExp, '/')\n}\n\nfunction staticImportedByEntry(\n  id: string,\n  getModuleInfo: GetModuleInfo,\n  cache: Map<string, boolean>,\n  importStack: string[] = []\n): boolean {\n  if (cache.has(id)) {\n    return cache.get(id) as boolean\n  }\n  if (importStack.includes(id)) {\n    // circular deps!\n    cache.set(id, false)\n    return false\n  }\n  const mod = getModuleInfo(id)\n  if (!mod) {\n    cache.set(id, false)\n    return false\n  }\n\n  if (mod.isEntry) {\n    cache.set(id, true)\n    return true\n  }\n  const someImporterIs = mod.importers.some((importer) =>\n    staticImportedByEntry(\n      importer,\n      getModuleInfo,\n      cache,\n      importStack.concat(id)\n    )\n  )\n  cache.set(id, someImporterIs)\n  return someImporterIs\n}\n","import { GetManualChunk, ManualChunksOption } from 'rollup'\r\nimport { manualChunksConfig } from './manualChunksConfig'\r\n\r\n/**\r\n * Call user defined functions that may be defined\r\n * at `build.rollupOptions.output` before calling\r\n * `manualChunksConfig`.\r\n */\r\nexport function getManualChunks(\r\n  initialManualChunks: ManualChunksOption | undefined\r\n): GetManualChunk {\r\n  const userDefinedManualChunks =\r\n    typeof initialManualChunks === 'function' ? initialManualChunks : undefined\r\n  return (id: string, opts) => {\r\n    if (userDefinedManualChunks) {\r\n      const result = userDefinedManualChunks(id, opts)\r\n      if (result) {\r\n        return result\r\n      }\r\n    }\r\n    return manualChunksConfig(id, opts)\r\n  }\r\n}\r\n","import type { Plugin, ResolvedConfig } from 'vite'\nimport type { GetModuleInfo, ManualChunksOption } from 'rollup'\nimport type { ResolverObject } from '@rollup/plugin-alias'\n\nimport { parse as parseImports } from 'es-module-lexer'\nimport MagicString from 'magic-string'\nimport alias from '@rollup/plugin-alias'\nimport { getManualChunks } from './utils'\nimport {\n  bundleName,\n  CHUNK_NAME_TAG,\n  moduleDeps,\n  chunkNameRE,\n  appRootPathRE,\n  userJSFilePathRE,\n  appModuleIdChunkNamesMap,\n  getFileName,\n  fileNameDelimiter,\n} from './share'\nimport { moduleImpoterMap } from './type.d'\n\nconst routeChunkNameRE = /(webpackC|c)hunkName:\\s*[\"']([\\w-/.]+)[\"']/\nconst nodeModuleRE = /node_modules\\/((@[^/]+\\/)?[^/]+)/g\nconst getNodeModulesName = (id: string) => {\n  let name = ''\n  let mached = null\n  while ((mached = nodeModuleRE.exec(id))) {\n    name = mached[1]\n  }\n\n  return name\n}\n\n// transform router content, eg:\n// import(/* webpackChunkName: \"detail\" */ \"@/detail/somepage.vue\")\n// trans to\n// import(\"@/detail/somepage.vue?chunkName=detail\")\n// so we can get chunkName params in manuanlChunks\n// also use chunkName: import(/* chunkName: \"detail\" */ \"@/detail/somepage.vue\")\nexport const manualChunksPlugin = function (): Plugin {\n  const nodeModuleIdSets: Set<string> = new Set()\n  const appModuleIdSets: Set<string> = new Set()\n  let _resolveIdByAlias: ResolverObject\n  let _config: ResolvedConfig\n\n  return {\n    name: 'manualNameChunksPlugin',\n    apply: 'build',\n    load(id) {\n      if (id.includes('node_modules')) {\n        nodeModuleIdSets.add(id)\n      } else if (appRootPathRE.test(id)) {\n        appModuleIdSets.add(id)\n      }\n      return null\n    },\n\n    configResolved(resolvedConfig) {\n      _config = resolvedConfig\n    },\n\n    buildEnd() {\n      const appModuleIdMap = appModuleId2chunkNamesMap(\n        appModuleIdSets,\n        this.getModuleInfo\n      )\n      const nodeModuleIdMap = nodeModuleId2issuerMap(\n        nodeModuleIdSets,\n        this.getModuleInfo\n      )\n      moduleDeps.set(nodeModuleIdMap)\n      appModuleIdChunkNamesMap.set(appModuleIdMap)\n    },\n\n    async transform(source, id) {\n      const hasConfigRouteChunkName =\n        userJSFilePathRE.test(id) && routeChunkNameRE.test(source)\n      if (hasConfigRouteChunkName) {\n        let str = new MagicString(source)\n        const imports = parseImports(source)[0]\n        for (let index = 0; index < imports.length; index++) {\n          const {\n            ss: sstart,\n            se: send,\n            s: start,\n            e: end,\n            n: rawValue,\n          } = imports[index]\n          const rawUrl = source.slice(sstart, send)\n          const matched = routeChunkNameRE.exec(rawUrl)\n          if (matched) {\n            const chunkName = matched[2].replace(/\\//g, fileNameDelimiter)\n\n            let resolvedId = rawValue\n            if (_resolveIdByAlias) {\n              const rid = await _resolveIdByAlias.resolveId.call(\n                this,\n                rawValue,\n                id\n              )\n              if (rid) resolvedId = rid.id\n            }\n            const newContent = `\"${resolvedId}?${CHUNK_NAME_TAG}=${chunkName}\"`\n            str = str.overwrite(start, end, newContent)\n          }\n        }\n        return {\n          code: str.toString(),\n          map: _config.build.sourcemap\n            ? str.generateMap({\n                includeContent: true,\n                hires: true,\n              })\n            : null,\n        }\n      }\n    },\n\n    config(userConfig) {\n      if (!userConfig.build) userConfig.build = {}\n      if (!userConfig.build.rollupOptions) userConfig.build.rollupOptions = {}\n      if (!userConfig.build.rollupOptions.output)\n        userConfig.build.rollupOptions.output = {}\n\n      const rollupOptions = userConfig.build.rollupOptions\n      const output = rollupOptions.output\n      if (Array.isArray(output)) {\n        rollupOptions.output = output.map((item) => {\n          item.manualChunks = getManualChunks(\n            item.manualChunks as ManualChunksOption\n          )\n          return item\n        })\n      } else {\n        Object.assign(userConfig.build.rollupOptions.output, {\n          manualChunks: getManualChunks(\n            output.manualChunks as ManualChunksOption\n          ),\n        })\n      }\n\n      const userAlias = userConfig.resolve && (userConfig.resolve.alias as any)\n      if (userAlias)\n        _resolveIdByAlias = alias({ entries: userAlias }) as ResolverObject\n    },\n  }\n}\n\nfunction appModuleId2chunkNamesMap(\n  idSets: Set<string>,\n  getModuleInfo: GetModuleInfo\n) {\n  const depMaps: moduleImpoterMap = {}\n  for (const id of idSets) {\n    if (depMaps[id]) continue\n\n    const rootNames = getImportersChunkNames(id, getModuleInfo, depMaps)\n    depMaps[id] = {\n      chunkNames: rootNames,\n    }\n  }\n  return depMaps\n}\n\nfunction getImportersChunkNames(\n  id: string,\n  getModuleInfo: GetModuleInfo,\n  depMaps: moduleImpoterMap\n): Set<string> {\n  const ids = [id]\n  const resSets = new Set<string>()\n  for (const sid of ids) {\n    const info = depMaps[sid]\n    if (info) {\n      info.chunkNames.forEach((item) => resSets.add(item))\n    } else {\n      const { isEntry, importers } = getModuleInfo(sid)\n      if (isEntry) {\n        resSets.add(bundleName.main)\n      } else if (importers.length === 0) {\n        const name = getDynamicModuleName(sid)\n        depMaps[sid] = {\n          chunkNames: new Set([name]),\n        }\n        resSets.add(name)\n      } else {\n        importers.forEach((item) => {\n          if (ids.indexOf(item) === -1) {\n            ids.push(item)\n          }\n        })\n      }\n    }\n  }\n  return resSets\n}\n\nconst dynamicNameCache = new Map<string, number>()\nfunction getDynamicModuleName(moduleId: string): string {\n  const chunkNameRes = chunkNameRE.exec(moduleId)\n  if (chunkNameRes) return chunkNameRes[1]\n\n  const fileName = getFileName(moduleId)\n  if (dynamicNameCache.has(fileName)) {\n    const count = dynamicNameCache.get(fileName)\n    dynamicNameCache.set(fileName, count + 1)\n    return `${fileName}-${count}`\n  }\n  dynamicNameCache.set(fileName, 1)\n  return fileName\n}\n\nfunction nodeModuleId2issuerMap(\n  idSets: Set<string>,\n  getModuleInfo: GetModuleInfo\n) {\n  // 获取每个id的祖先发起者\n  const depMaps: moduleImpoterMap = {}\n  for (const id of idSets) {\n    if (!depMaps[id]) {\n      const moduleName = getNodeModulesName(id)\n      depMaps[id] = {\n        chunkNames: new Set([moduleName]),\n        name: moduleName,\n      }\n    }\n    const { importedIds } = getModuleInfo(id)\n    const depSets: Set<string> = new Set(importedIds)\n    for (const importedId of depSets) {\n      if (!depMaps[importedId]) {\n        depMaps[importedId] = {\n          chunkNames: new Set(),\n          name: getNodeModulesName(importedId),\n        }\n      }\n      ;[...depMaps[id].chunkNames].forEach((mid) =>\n        depMaps[importedId].chunkNames.add(mid)\n      )\n      ;((getModuleInfo(importedId) || {}).importedIds || []).forEach(\n        (mid: string) => depSets.add(mid)\n      )\n    }\n  }\n  return depMaps\n}\n"],"names":["APP_ROOT_PATH","normalizePath","process","cwd","appRootPathRE","RegExp","userJSFilePathRE","chunkNameRE","bundleName","main","vendor","getFileName","filePath","basename","extname","__moduleDeps","moduleDeps","get","id","set","v","__appDepMap","appModuleIdChunkNamesMap","fileNameDelimiterRegExp","cssLangRE","isCSSRequest","request","test","__moduleInVenderMap","Map","manualChunksConfig","opts","getModuleInfo","cacheIdMap","nodeModuleInfo","isNodeModules","isInternalModule","staticImportedByEntry","has","name","matchedChunkName","exec","formatChunkName","length","rootModule","__spreadArray","__read","chunkNames","chunkName","appModuleInfo","name_1","indexOf","names","filter","i","_a","sort","a","b","c1","c2","concat","assembleChunkName","getAppModuleChunkName","Boolean","replace","cache","importStack","includes","mod","isEntry","someImporterIs","importers","some","importer","getManualChunks","initialManualChunks","userDefinedManualChunks","undefined","result","routeChunkNameRE","nodeModuleRE","getNodeModulesName","mached","getImportersChunkNames","depMaps","ids","resSets","Set","ids_1","__values","ids_1_1","done","next","sid","value","info","forEach","item","add","_b","getDynamicModuleName","push","dynamicNameCache","moduleId","chunkNameRes","fileName","count","_resolveIdByAlias","_config","nodeModuleIdSets","appModuleIdSets","apply","load","configResolved","resolvedConfig","buildEnd","appModuleIdMap","idSets","idSets_1","idSets_1_1","rootNames","appModuleId2chunkNamesMap","this","nodeModuleIdMap","moduleName","importedIds","depSets","importedId","mid","depSets_1","e_4","depSets_1_1","idSets_2","idSets_2_1","nodeModuleId2issuerMap","transform","source","str","MagicString","imports","parseImports","parse","index","sstart","send","start","end","rawValue","rawUrl","slice","matched","resolvedId","resolveId","call","rid","sent","newContent","overwrite","code","toString","map","build","sourcemap","generateMap","includeContent","hires","config","userConfig","rollupOptions","output","Array","isArray","manualChunks","Object","assign","userAlias","resolve","alias","entries"],"mappings":"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"}