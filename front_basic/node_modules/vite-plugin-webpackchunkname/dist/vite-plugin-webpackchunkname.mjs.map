{"version":3,"file":"vite-plugin-webpackchunkname.mjs","sources":["../src/share.ts","../src/manualChunksConfig.ts","../src/utils.ts","../src/index.ts"],"sourcesContent":["import { basename, extname } from 'path'\nimport { moduleImpoterMap } from './type.d'\nimport { normalizePath } from '@rollup/pluginutils'\n\nconst APP_ROOT_PATH = normalizePath(process.cwd())\nexport const appRootPathRE = new RegExp(APP_ROOT_PATH, 'i')\nexport const userJSFilePathRE = new RegExp(\n  APP_ROOT_PATH + '/(?!node_modules).*\\\\.[tj]s[x]?$',\n  'i'\n)\nexport const CHUNK_NAME_TAG = 'chunkName'\nexport const chunkNameRE = /\\?chunkName=([\\w-.]*)/\nexport const bundleName = {\n  main: 'common',\n  vendor: 'vendor',\n}\nexport const fileNameDelimiter = '__'\n\nexport const getFileName = (filePath: string) => {\n  return basename(filePath, extname(filePath))\n}\n\nlet __moduleDeps: moduleImpoterMap = null\nexport const moduleDeps = {\n  get(id: string) {\n    return __moduleDeps[id]\n  },\n  set(v: moduleImpoterMap) {\n    __moduleDeps = v\n  },\n}\n\nlet __appDepMap: moduleImpoterMap = null\nexport const appModuleIdChunkNamesMap = {\n  get(id: string) {\n    return __appDepMap[id]\n  },\n  set(v: moduleImpoterMap) {\n    __appDepMap = v\n  },\n}\n","import type { GetModuleInfo } from 'rollup'\nimport {\n  bundleName,\n  chunkNameRE,\n  appRootPathRE,\n  moduleDeps,\n  appModuleIdChunkNamesMap,\n  fileNameDelimiter,\n} from './share'\n\nconst fileNameDelimiterRegExp = new RegExp(fileNameDelimiter, 'g')\n\nconst cssLangs = `\\\\.(css|less|sass|scss|styl|stylus|pcss|postcss)($|\\\\?)`\nconst cssLangRE = new RegExp(cssLangs)\nconst isCSSRequest = (request: string): boolean => cssLangRE.test(request)\n\nconst __moduleInVenderMap = new Map<string, boolean>()\n\n// rollup 把入口文件打包成index-[hash].js，名字 index.html 保持一致\n// 此文件【不export】任何变量，所以即使部分内容发生变化，也能保证多数包能够被长效缓存\n/**\n * 打包策略（靠前优先）：\n * 1. 从入口文件引入的三方包，打包成 vendor\n * 2. 路由带有 webpackChunkName 的，按给定的名称打包\n * 3. 文件有且只有一次引用，按 rollup 默认逻辑\n * 4. 文件多次引用\n *  4.1 如果是 node_modules 模块，按包名打包\n *  4.2 如果是用户模块按照 getAppModuleChunkName 中的逻辑打包\n */\n\nexport function manualChunksConfig(\n  id: string,\n  opts: { getModuleInfo: GetModuleInfo }\n) {\n  const { getModuleInfo } = opts\n  const cacheIdMap = new Map<string, boolean>()\n  const nodeModuleInfo = moduleDeps.get(id)\n  const isNodeModules = !!nodeModuleInfo\n\n  // vite 用的模块，譬如：__vite-browser-external，plugin-vue:export-helper 等\n  const isInternalModule = !appRootPathRE.test(id)\n  const isThirdPackageImportByEntry =\n    isNodeModules &&\n    !isCSSRequest(id) &&\n    staticImportedByEntry(id, getModuleInfo, cacheIdMap)\n  if (isThirdPackageImportByEntry || isInternalModule) {\n    if (nodeModuleInfo && !__moduleInVenderMap.has(nodeModuleInfo.name)) {\n      __moduleInVenderMap.set(nodeModuleInfo.name, true)\n    }\n    return bundleName.vendor\n  }\n\n  const matchedChunkName = chunkNameRE.exec(id)\n  if (matchedChunkName) {\n    return formatChunkName(matchedChunkName[1])\n  }\n\n  const { importers } = getModuleInfo(id)\n  if (importers.length < 2) {\n    return void 0\n  }\n\n  //importers 大于 1 就存在chunk之间的引用\n\n  // 处理node_modules中的依赖\n  if (nodeModuleInfo) {\n    const rootModule = [...nodeModuleInfo.chunkNames]\n    let chunkName = rootModule[0]\n    if (rootModule.length >= 2) {\n      chunkName = nodeModuleInfo.name\n    }\n    if (__moduleInVenderMap.has(chunkName)) {\n      chunkName = bundleName.vendor\n    }\n    return chunkName || bundleName.main\n  }\n\n  const appModuleInfo = appModuleIdChunkNamesMap.get(id)\n  if (appModuleInfo) {\n    const chunkNames = [...appModuleInfo.chunkNames].filter(Boolean)\n    const name = getAppModuleChunkName(chunkNames)\n    return formatChunkName(name)\n  }\n}\n\nfunction getAppModuleChunkName(chunkNames: string[]) {\n  if (chunkNames.indexOf(bundleName.main) >= 0) {\n    return bundleName.main\n  }\n\n  const names = chunkNames.filter((i: string) => i !== bundleName.main)\n  switch (names.length) {\n    case 1:\n      return names[0]\n    case 2:\n      return assembleChunkName(names)\n    default:\n      return bundleName.main\n  }\n}\n\nfunction assembleChunkName(names: string[]) {\n  const [c1, c2] = names.sort((a, b) => (a > b ? 1 : a < b ? -1 : 0))\n  return `shared/${c1}/${c2}`\n}\n\nfunction formatChunkName(name: string) {\n  return name.replace(fileNameDelimiterRegExp, '/')\n}\n\nfunction staticImportedByEntry(\n  id: string,\n  getModuleInfo: GetModuleInfo,\n  cache: Map<string, boolean>,\n  importStack: string[] = []\n): boolean {\n  if (cache.has(id)) {\n    return cache.get(id) as boolean\n  }\n  if (importStack.includes(id)) {\n    // circular deps!\n    cache.set(id, false)\n    return false\n  }\n  const mod = getModuleInfo(id)\n  if (!mod) {\n    cache.set(id, false)\n    return false\n  }\n\n  if (mod.isEntry) {\n    cache.set(id, true)\n    return true\n  }\n  const someImporterIs = mod.importers.some((importer) =>\n    staticImportedByEntry(\n      importer,\n      getModuleInfo,\n      cache,\n      importStack.concat(id)\n    )\n  )\n  cache.set(id, someImporterIs)\n  return someImporterIs\n}\n","import { GetManualChunk, ManualChunksOption } from 'rollup'\r\nimport { manualChunksConfig } from './manualChunksConfig'\r\n\r\n/**\r\n * Call user defined functions that may be defined\r\n * at `build.rollupOptions.output` before calling\r\n * `manualChunksConfig`.\r\n */\r\nexport function getManualChunks(\r\n  initialManualChunks: ManualChunksOption | undefined\r\n): GetManualChunk {\r\n  const userDefinedManualChunks =\r\n    typeof initialManualChunks === 'function' ? initialManualChunks : undefined\r\n  return (id: string, opts) => {\r\n    if (userDefinedManualChunks) {\r\n      const result = userDefinedManualChunks(id, opts)\r\n      if (result) {\r\n        return result\r\n      }\r\n    }\r\n    return manualChunksConfig(id, opts)\r\n  }\r\n}\r\n","import type { Plugin, ResolvedConfig } from 'vite'\nimport type { GetModuleInfo, ManualChunksOption } from 'rollup'\nimport type { ResolverObject } from '@rollup/plugin-alias'\n\nimport { parse as parseImports } from 'es-module-lexer'\nimport MagicString from 'magic-string'\nimport alias from '@rollup/plugin-alias'\nimport { getManualChunks } from './utils'\nimport {\n  bundleName,\n  CHUNK_NAME_TAG,\n  moduleDeps,\n  chunkNameRE,\n  appRootPathRE,\n  userJSFilePathRE,\n  appModuleIdChunkNamesMap,\n  getFileName,\n  fileNameDelimiter,\n} from './share'\nimport { moduleImpoterMap } from './type.d'\n\nconst routeChunkNameRE = /(webpackC|c)hunkName:\\s*[\"']([\\w-/.]+)[\"']/\nconst nodeModuleRE = /node_modules\\/((@[^/]+\\/)?[^/]+)/g\nconst getNodeModulesName = (id: string) => {\n  let name = ''\n  let mached = null\n  while ((mached = nodeModuleRE.exec(id))) {\n    name = mached[1]\n  }\n\n  return name\n}\n\n// transform router content, eg:\n// import(/* webpackChunkName: \"detail\" */ \"@/detail/somepage.vue\")\n// trans to\n// import(\"@/detail/somepage.vue?chunkName=detail\")\n// so we can get chunkName params in manuanlChunks\n// also use chunkName: import(/* chunkName: \"detail\" */ \"@/detail/somepage.vue\")\nexport const manualChunksPlugin = function (): Plugin {\n  const nodeModuleIdSets: Set<string> = new Set()\n  const appModuleIdSets: Set<string> = new Set()\n  let _resolveIdByAlias: ResolverObject\n  let _config: ResolvedConfig\n\n  return {\n    name: 'manualNameChunksPlugin',\n    apply: 'build',\n    load(id) {\n      if (id.includes('node_modules')) {\n        nodeModuleIdSets.add(id)\n      } else if (appRootPathRE.test(id)) {\n        appModuleIdSets.add(id)\n      }\n      return null\n    },\n\n    configResolved(resolvedConfig) {\n      _config = resolvedConfig\n    },\n\n    buildEnd() {\n      const appModuleIdMap = appModuleId2chunkNamesMap(\n        appModuleIdSets,\n        this.getModuleInfo\n      )\n      const nodeModuleIdMap = nodeModuleId2issuerMap(\n        nodeModuleIdSets,\n        this.getModuleInfo\n      )\n      moduleDeps.set(nodeModuleIdMap)\n      appModuleIdChunkNamesMap.set(appModuleIdMap)\n    },\n\n    async transform(source, id) {\n      const hasConfigRouteChunkName =\n        userJSFilePathRE.test(id) && routeChunkNameRE.test(source)\n      if (hasConfigRouteChunkName) {\n        let str = new MagicString(source)\n        const imports = parseImports(source)[0]\n        for (let index = 0; index < imports.length; index++) {\n          const {\n            ss: sstart,\n            se: send,\n            s: start,\n            e: end,\n            n: rawValue,\n          } = imports[index]\n          const rawUrl = source.slice(sstart, send)\n          const matched = routeChunkNameRE.exec(rawUrl)\n          if (matched) {\n            const chunkName = matched[2].replace(/\\//g, fileNameDelimiter)\n\n            let resolvedId = rawValue\n            if (_resolveIdByAlias) {\n              const rid = await _resolveIdByAlias.resolveId.call(\n                this,\n                rawValue,\n                id\n              )\n              if (rid) resolvedId = rid.id\n            }\n            const newContent = `\"${resolvedId}?${CHUNK_NAME_TAG}=${chunkName}\"`\n            str = str.overwrite(start, end, newContent)\n          }\n        }\n        return {\n          code: str.toString(),\n          map: _config.build.sourcemap\n            ? str.generateMap({\n                includeContent: true,\n                hires: true,\n              })\n            : null,\n        }\n      }\n    },\n\n    config(userConfig) {\n      if (!userConfig.build) userConfig.build = {}\n      if (!userConfig.build.rollupOptions) userConfig.build.rollupOptions = {}\n      if (!userConfig.build.rollupOptions.output)\n        userConfig.build.rollupOptions.output = {}\n\n      const rollupOptions = userConfig.build.rollupOptions\n      const output = rollupOptions.output\n      if (Array.isArray(output)) {\n        rollupOptions.output = output.map((item) => {\n          item.manualChunks = getManualChunks(\n            item.manualChunks as ManualChunksOption\n          )\n          return item\n        })\n      } else {\n        Object.assign(userConfig.build.rollupOptions.output, {\n          manualChunks: getManualChunks(\n            output.manualChunks as ManualChunksOption\n          ),\n        })\n      }\n\n      const userAlias = userConfig.resolve && (userConfig.resolve.alias as any)\n      if (userAlias)\n        _resolveIdByAlias = alias({ entries: userAlias }) as ResolverObject\n    },\n  }\n}\n\nfunction appModuleId2chunkNamesMap(\n  idSets: Set<string>,\n  getModuleInfo: GetModuleInfo\n) {\n  const depMaps: moduleImpoterMap = {}\n  for (const id of idSets) {\n    if (depMaps[id]) continue\n\n    const rootNames = getImportersChunkNames(id, getModuleInfo, depMaps)\n    depMaps[id] = {\n      chunkNames: rootNames,\n    }\n  }\n  return depMaps\n}\n\nfunction getImportersChunkNames(\n  id: string,\n  getModuleInfo: GetModuleInfo,\n  depMaps: moduleImpoterMap\n): Set<string> {\n  const ids = [id]\n  const resSets = new Set<string>()\n  for (const sid of ids) {\n    const info = depMaps[sid]\n    if (info) {\n      info.chunkNames.forEach((item) => resSets.add(item))\n    } else {\n      const { isEntry, importers } = getModuleInfo(sid)\n      if (isEntry) {\n        resSets.add(bundleName.main)\n      } else if (importers.length === 0) {\n        const name = getDynamicModuleName(sid)\n        depMaps[sid] = {\n          chunkNames: new Set([name]),\n        }\n        resSets.add(name)\n      } else {\n        importers.forEach((item) => {\n          if (ids.indexOf(item) === -1) {\n            ids.push(item)\n          }\n        })\n      }\n    }\n  }\n  return resSets\n}\n\nconst dynamicNameCache = new Map<string, number>()\nfunction getDynamicModuleName(moduleId: string): string {\n  const chunkNameRes = chunkNameRE.exec(moduleId)\n  if (chunkNameRes) return chunkNameRes[1]\n\n  const fileName = getFileName(moduleId)\n  if (dynamicNameCache.has(fileName)) {\n    const count = dynamicNameCache.get(fileName)\n    dynamicNameCache.set(fileName, count + 1)\n    return `${fileName}-${count}`\n  }\n  dynamicNameCache.set(fileName, 1)\n  return fileName\n}\n\nfunction nodeModuleId2issuerMap(\n  idSets: Set<string>,\n  getModuleInfo: GetModuleInfo\n) {\n  // 获取每个id的祖先发起者\n  const depMaps: moduleImpoterMap = {}\n  for (const id of idSets) {\n    if (!depMaps[id]) {\n      const moduleName = getNodeModulesName(id)\n      depMaps[id] = {\n        chunkNames: new Set([moduleName]),\n        name: moduleName,\n      }\n    }\n    const { importedIds } = getModuleInfo(id)\n    const depSets: Set<string> = new Set(importedIds)\n    for (const importedId of depSets) {\n      if (!depMaps[importedId]) {\n        depMaps[importedId] = {\n          chunkNames: new Set(),\n          name: getNodeModulesName(importedId),\n        }\n      }\n      ;[...depMaps[id].chunkNames].forEach((mid) =>\n        depMaps[importedId].chunkNames.add(mid)\n      )\n      ;((getModuleInfo(importedId) || {}).importedIds || []).forEach(\n        (mid: string) => depSets.add(mid)\n      )\n    }\n  }\n  return depMaps\n}\n"],"names":["APP_ROOT_PATH","normalizePath","process","cwd","appRootPathRE","RegExp","userJSFilePathRE","chunkNameRE","bundleName","main","vendor","getFileName","filePath","basename","extname","__moduleDeps","moduleDeps","get","id","set","v","__appDepMap","appModuleIdChunkNamesMap","fileNameDelimiterRegExp","cssLangRE","isCSSRequest","request","test","__moduleInVenderMap","Map","manualChunksConfig","opts","getModuleInfo","cacheIdMap","nodeModuleInfo","isNodeModules","isInternalModule","staticImportedByEntry","has","name","matchedChunkName","exec","formatChunkName","length","rootModule","__spreadArray","__read","chunkNames","chunkName","appModuleInfo","name_1","indexOf","names","filter","i","_a","sort","a","b","c1","c2","concat","assembleChunkName","getAppModuleChunkName","Boolean","replace","cache","importStack","includes","mod","isEntry","someImporterIs","importers","some","importer","getManualChunks","initialManualChunks","userDefinedManualChunks","undefined","result","routeChunkNameRE","nodeModuleRE","getNodeModulesName","mached","manualChunksPlugin","_resolveIdByAlias","_config","nodeModuleIdSets","Set","appModuleIdSets","apply","load","add","configResolved","resolvedConfig","buildEnd","appModuleIdMap","idSets","depMaps","idSets_1","__values","idSets_1_1","done","next","value","rootNames","getImportersChunkNames","appModuleId2chunkNamesMap","this","nodeModuleIdMap","moduleName","importedIds","depSets","importedId","forEach","mid","depSets_1","e_4","depSets_1_1","idSets_2","idSets_2_1","nodeModuleId2issuerMap","transform","source","str","MagicString","imports","parseImports","index","sstart","send","start","end","rawValue","rawUrl","slice","matched","resolvedId","resolveId","call","rid","_b","sent","newContent","overwrite","code","toString","map","build","sourcemap","generateMap","includeContent","hires","config","userConfig","rollupOptions","output","Array","isArray","item","manualChunks","Object","assign","userAlias","resolve","alias","entries","ids","resSets","ids_1","ids_1_1","sid","info","getDynamicModuleName","push","dynamicNameCache","moduleId","chunkNameRes","fileName","count"],"mappings":"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"}